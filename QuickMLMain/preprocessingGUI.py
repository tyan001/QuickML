# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'NeuralNetworkGUI.ui'
#
# Created by: PyQt5 UI code generator 5.15.1
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
import preprocessingFunctions
import os
import multiprocessing as mp
import shutil
import random
 
class Ui_MainWindow(object):
    def __init__(self):
        self.icon = QtGui.QIcon()
        self.icon.addPixmap(QtGui.QPixmap("Directory.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)

    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1130, 722)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.addDirectoryBtn = QtWidgets.QToolButton(self.centralwidget)
        self.addDirectoryBtn.setGeometry(QtCore.QRect(10, 10, 75, 23))
        self.addDirectoryBtn.setObjectName("addDirectoryBtn")
        self.toolBtn = QtWidgets.QToolButton(self.centralwidget)
        self.toolBtn.setGeometry(QtCore.QRect(90, 10, 75, 23))
        self.toolBtn.setObjectName("toolBtn")
        self.deleteBtn = QtWidgets.QPushButton(self.centralwidget)
        self.deleteBtn.setGeometry(QtCore.QRect(950, 610, 75, 23))
        self.deleteBtn.setObjectName("deleteBtn")
        self.deleteAllBtn = QtWidgets.QPushButton(self.centralwidget)
        self.deleteAllBtn.setGeometry(QtCore.QRect(1030, 610, 75, 23))
        self.deleteAllBtn.setObjectName("deleteAllBtn")
        self.saveBtn = QtWidgets.QPushButton(self.centralwidget)
        self.saveBtn.setGeometry(QtCore.QRect(950, 640, 75, 23))
        self.saveBtn.setObjectName("saveBtn")
        self.nextBtn = QtWidgets.QPushButton(self.centralwidget)
        self.nextBtn.setGeometry(QtCore.QRect(1030, 640, 75, 23))
        self.nextBtn.setObjectName("nextBtn")
        self.listWidget = QtWidgets.QListWidget(self.centralwidget)
        self.listWidget.setGeometry(QtCore.QRect(10, 40, 461, 641))
        self.listWidget.setObjectName("listWidget")
        self.listWidget_2 = QtWidgets.QListWidget(self.centralwidget)
        self.listWidget_2.setGeometry(QtCore.QRect(480, 40, 461, 641))
        self.listWidget_2.setObjectName("listWidget_2")
        self.lineEdit = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit.setGeometry(QtCore.QRect(170, 10, 771, 20))
        self.lineEdit.setObjectName("lineEdit")
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1130, 21))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

        self.toolBtn.setIcon(self.icon)
        self.deleteBtn.clicked.connect(lambda: self.delete_class_dia())
        self.toolBtn.clicked.connect(lambda: self.directory_dialog())
        self.addDirectoryBtn.clicked.connect(lambda: self.add_directory())
        self.saveBtn.clicked.connect(lambda: self.create_directory())
        self.deleteAllBtn.clicked.connect(lambda: self.delete_all())

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.addDirectoryBtn.setText(_translate("MainWindow", "+"))
        self.toolBtn.setText(_translate("MainWindow", "..."))
        self.deleteBtn.setText(_translate("MainWindow", "Delete"))
        self.deleteAllBtn.setText(_translate("MainWindow", "Delete All"))
        self.saveBtn.setText(_translate("MainWindow", "Save"))
        self.nextBtn.setText(_translate("MainWindow", "Next"))

    def close_dialog(self):
        close_message = QtWidgets.QMessageBox()
        close_message.setWindowTitle("Continue?")
        close_message.setText("You sure you want to close?")
        close_message.setStandardButtons(QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
        close_message.setIcon(QtWidgets.QMessageBox.Question)
        ret = close_message.exec()

        if ret == QtWidgets.QMessageBox.Yes:
            QtCore.QCoreApplication.instance().quit()

    def directory_dialog(self):
        path_to_directory = QtWidgets.QFileDialog.getExistingDirectory(None, "Choose Directory")
        self.lineEdit.setText(path_to_directory)

    def add_directory(self):

        path_to_directory = self.lineEdit.text()
        self.listWidget.addItem(path_to_directory)
        self.create_class_dia()
        print('hello')

    def create_class_dia(self):
        class_dia, result = QtWidgets.QInputDialog.getText(None, "Class Name", "Input Class Name")
        if result:
            self.listWidget_2.addItem(class_dia)

    def delete_class_dia(self):
        index = self.listWidget.currentRow()
        item1 = self.listWidget.takeItem(index)
        item2 = self.listWidget_2.takeItem(index)
        self.listWidget.removeItemWidget(item1)
        self.listWidget_2.removeItemWidget(item2)

    def delete_all(self):
        self.listWidget.clear()
        self.listWidget_2.clear()

    def zip_directories(self):
        paths = []
        labels = []
        for index in range(self.listWidget.count()):
            paths.append(self.listWidget.item(index).text())
            labels.append(self.listWidget_2.item(index).text())

        preprocessingFunctions.zip_files(paths, labels)

    def finish_dialog(self):
        finish_message = QtWidgets.QMessageBox()
        finish_message.setWindowTitle("Finished")
        finish_message.setText("Program has finished")
        finish_message.setStandardButtons(QtWidgets.QMessageBox.Ok)
        finish_message.setIcon(QtWidgets.QMessageBox.Information)
        ret = finish_message.exec()

    def create_directory(self):
        project_name, result = QtWidgets.QInputDialog.getText(None, "Project Name", "Input Project Name")

        paths = []
        labels = []
        for index in range(self.listWidget.count()):
            paths.append(self.listWidget.item(index).text())
            labels.append(self.listWidget_2.item(index).text())

        print(labels)
        print(paths)
        print(project_name)
       # preprocessingFunctions.copy_directory(paths, labels, project_name)
        preprocessingFunctions.multi_process_dataset(project_name, labels, paths)
        self.finish_dialog()

    def make_data_directories(self,dir_name, labels):
        # dir_name - Top level directory name
        # labels - labels names. (e.g. cats, dogs, horses)
        try:
            os.mkdir(dir_name)  # making top level directory
        except OSError as e:
            print(e.filename, 'exists already')
            pass

        train_path = os.path.join(dir_name, 'training')
        testing_path = os.path.join(dir_name, 'testing')

        try:
            os.mkdir(train_path)  # making training subdirectory
        except FileExistsError as e:
            print(e.filename, 'exists already')
            pass

        try:
            os.mkdir(testing_path)  # making testing subdirectory
        except FileExistsError as e:
            print(e.filename, 'exists already')
            pass

        for i in range(len(labels)):  # making training labels and testing labels subdirectory
            try:
                os.mkdir(os.path.join(train_path, str(labels[i])))
            except OSError as e:
                print(e.filename, 'exists already')
                pass

            try:
                os.mkdir(os.path.join(testing_path, str(labels[i])))
            except OSError as e:
                print(e.filename, 'exists already')
                pass

    def split_data(self, SOURCE, TRAINING, TESTING, SPLIT_SIZE):
        # SOURCE - Path location where the images are located
        # TRAINING - Path location where the training data will be moved to
        # TESTING - Path location where the testing data will be moved to
        # SPLIT_SIZE = The amount of images going to the training dataset by %.
        # (e.g. SPLIT_SIZE = .9: total images = 100, 90 images goes to training directory, 10 images goes to test directory)

        testing_file_names = []
        file_names = os.listdir(SOURCE)  #
        t = round(len(file_names) * (1 - SPLIT_SIZE))
        random.shuffle(file_names)
        for i in range(int(t)):
            testing_file_names.append(file_names[i])  # adding the file names for the testing data set
            file_names.remove(file_names[i])  # removing the testing data file names

        for jpg in range(
                len(testing_file_names)):  # using the testing file names to move from source to testing directory
            shutil.copy2(os.path.join(SOURCE, testing_file_names[jpg]), TESTING)

        for jpg in range(len(file_names)):  # # using the file names to move from source to training directory
            shutil.copy2(os.path.join(SOURCE, file_names[jpg]), TRAINING)

    def make_dataset(self,new_dir, labels, src_directories):
        self.make_data_directories(new_dir, labels)
        for i in range(len(labels)):
            split_data(SOURCE=src_directories[i],
                       TRAINING=os.path.join(new_dir, 'training', labels[i]),
                       TESTING=os.path.join(new_dir, 'testing', labels[i]),
                       SPLIT_SIZE=0.8)

    def multi_process_dataset(self, new_dir, labels, src_directories):
        self.make_data_directories(new_dir, labels)
        processes = []
        for i in range(len(labels)):
            training_path = os.path.join(new_dir, 'training', labels[i])
            testing_path = os.path.join(new_dir, 'testing', labels[i])
            p = mp.Process(target=self.split_data, args=(src_directories[i], training_path, testing_path, 0.9))
            processes.append(p)
            p.start()

        for process in processes:
            process.join()



